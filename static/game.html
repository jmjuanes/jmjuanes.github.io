
<div id="root" style="width:100%;height:100%;position:fixed;top:0;left:0;overflow:hidden;user-select:none;">
    <svg width="1" height="1" style="background-color: #f0f0f0"></svg>
</div>

<script type="text/javascript">
    
    // internal game state
    const game = {
        parent: document.querySelector(`div#root`),
        width: 0,
        height: 0,
        score: 0,

    };

    // initialize game
    const initializeGame = () => {
        const resizeGame = () => {
            const currentSize = game.parent.getBoundingClientRect();
            game.width = currentSize.width;
            game.height = currentSize.height;
            game.parent.querySelector(`svg`).setAttribute("width", game.width);
            game.parent.querySelector(`svg`).setAttribute("height", game.height);
            // game.parent.setAttribute("viewBox", `0 0 ${game.width} ${game.height}`);
        };
        window.addEventListener("resize", resizeGame);
        resizeGame();

    };

    initializeGame();


  const svg = document.getElementById("space");
  const ship = document.getElementById("ship");
  const planet = document.getElementById("planet");

  const cx = parseFloat(planet.getAttribute("cx"));
  const cy = parseFloat(planet.getAttribute("cy"));
  const orbitRadius = 30;

  const shipWidth = 32;
const shipHeight = 32;
  let angle = 0;
  let launched = false;
  let position = { x: 0, y: 0 };
  let velocity = { x: 0, y: 0 };

    const planetRadius = 20;
    const numPlanets = 5;
    const planets = [];
    const moons = [];

    function getCurrentViewBox(svg) {
        const vb = svg.getAttribute("viewBox").split(" ").map(Number);
        return { x: vb[0], y: vb[1], w: vb[2], h: vb[3] };
    }

    function zoomOut(svg, factor = 2, duration = 1000) {
  const start = getCurrentViewBox(svg);
  const end = {
    x: start.x - (start.w * (factor - 1)) / 2,
    y: start.y - (start.h * (factor - 1)) / 2,
    w: start.w * factor,
    h: start.h * factor
  };

  const startTime = performance.now();

  function step(now) {
    const t = Math.min((now - startTime) / duration, 1);
    const ease = t * (2 - t); // ease-out

    const x = start.x + (end.x - start.x) * ease;
    const y = start.y + (end.y - start.y) * ease;
    const w = start.w + (end.w - start.w) * ease;
    const h = start.h + (end.h - start.h) * ease;

    svg.setAttribute("viewBox", `${x} ${y} ${w} ${h}`);

    if (t < 1) requestAnimationFrame(step);
  }

  requestAnimationFrame(step);
}

function zoomIn(svg, factor = 2.5, duration = 1000) {
  const start = getCurrentViewBox(svg);
  const end = {
    x: start.x + (start.w * (1 - 1 / factor)) / 2,
    y: start.y + (start.h * (1 - 1 / factor)) / 2,
    w: start.w / factor,
    h: start.h / factor
  };

  const startTime = performance.now();

  function step(now) {
    const t = Math.min((now - startTime) / duration, 1);
    const ease = t * (2 - t);

    const x = start.x + (end.x - start.x) * ease;
    const y = start.y + (end.y - start.y) * ease;
    const w = start.w + (end.w - start.w) * ease;
    const h = start.h + (end.h - start.h) * ease;

    svg.setAttribute("viewBox", `${x} ${y} ${w} ${h}`);

    if (t < 1) requestAnimationFrame(step);
  }

  requestAnimationFrame(step);
}

function createParticle(svg, x, y) {
  const particle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
  particle.setAttribute("cx", x);
  particle.setAttribute("cy", y);
  particle.setAttribute("r", Math.random() * 5 + 1); // tamaño aleatorio
  particle.setAttribute("fill", "black");
  particle.setAttribute("opacity", "1");
  svg.appendChild(particle);

  const dx = (Math.random() - 0.5) * 100; // desplazamiento aleatorio
  const dy = (Math.random() - 0.5) * 100;
  const duration = 1000 + Math.random() * 500;

  const startTime = performance.now();

  function animate(now) {
    const t = Math.min((now - startTime) / duration, 1);
    const ease = 1 - t;

    particle.setAttribute("cx", x + dx * t);
    particle.setAttribute("cy", y + dy * t);
    particle.setAttribute("opacity", ease);

    if (t < 1) {
      requestAnimationFrame(animate);
    } else {
      particle.remove();
    }
  }

  requestAnimationFrame(animate);
}

function createEngineParticle(svg, x, y, angle) {
  const particle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
  particle.setAttribute("cx", x);
  particle.setAttribute("cy", y);
  particle.setAttribute("r", Math.random() * 1.5 + 0.5);
  particle.setAttribute("fill", "orange");
  particle.setAttribute("opacity", "1");
  svg.appendChild(particle);

  const speed = Math.random() * 10 + 5;
  const dx = -Math.cos(angle) * speed + (Math.random() - 0.5) * 4;
  const dy = -Math.sin(angle) * speed + (Math.random() - 0.5) * 4;
  const duration = 500;

  const startTime = performance.now();

  function animate(now) {
    const t = Math.min((now - startTime) / duration, 1);
    particle.setAttribute("cx", x + dx * t);
    particle.setAttribute("cy", y + dy * t);
    particle.setAttribute("opacity", 1 - t);

    if (t < 1) {
      requestAnimationFrame(animate);
    } else {
      particle.remove();
    }
  }

  requestAnimationFrame(animate);
}


    function createPlanets() {
      for (let i = 0; i < numPlanets; i++) {
        const x = Math.random() * (svg.clientWidth - 2 * planetRadius) + planetRadius;
        const y = Math.random() * (svg.clientHeight - 2 * planetRadius) + planetRadius;

        const planet = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        planet.setAttribute("cx", x);
        planet.setAttribute("cy", y);
        planet.setAttribute("r", planetRadius);
        planet.setAttribute("fill", "rgba(0,0,0,0.5)");
        svg.appendChild(planet);

        planets.push({ x, y, r: planetRadius });
      }
    }


function createMoons() {
  for (const planet of planets) {
    const moon = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    moon.setAttribute("r", 5);
    moon.setAttribute("fill", "rgba(0,0,0,0.3)");
    svg.appendChild(moon);

    moons.push({
      planet,
      element: moon,
      angle: Math.random() * Math.PI * 2,
      radius: 30 + Math.random() * 20, // distancia desde el planeta
      speed: 0.01 + Math.random() * 0.02
    });
  }
}


    createPlanets();
    createMoons();
    let currentPlanet = planets[0];

function checkCollision() {
  for (const p of planets) {
    const dx = position.x - p.x;
    const dy = position.y - p.y;
    const distance = Math.sqrt(dx * dx + dy * dy);

    if (distance < p.r + 5) {
      console.log("¡Has llegado a un planeta!");
      // Reiniciar órbita en el nuevo planeta
      currentPlanet = p;
      angle = 0;
      launched = false;
      velocity = { x: 0, y: 0 };
      animateViewBoxTo(svg, p.x, p.y); // ¡Aquí ocurre la magia!
      // zoomIn(svg, 2.5, 500);
      return false;
    }
  }
  return true;
}

function checkMoonCollision() {
  for (const moon of moons) {
    const mx = moon.element.getAttribute("cx");
    const my = moon.element.getAttribute("cy");
    const dx = position.x - mx;
    const dy = position.y - my;
    const distance = Math.sqrt(dx * dx + dy * dy);

    if (distance < 5 + 5) { // radio de nave + radio de luna
      console.log("¡Colisión con luna! Fin del juego.");
      launched = false;
      velocity = { x: 0, y: 0 };
      // Aquí podrías mostrar un mensaje o reiniciar el juego
      //Mostramos las particulas como si fiera una explosión
      for (let i = 0; i < 30; i++) {
  createParticle(svg, position.x, position.y);
}
      return true;
    }
  }
  return false;
}

function animateViewBoxTo(svg, targetX, targetY, duration = 1000) {
  const start = getCurrentViewBox(svg);
  const end = {
    x: targetX - start.w / 2,
    y: targetY - start.h / 2,
    w: start.w,
    h: start.h
  };

  const startTime = performance.now();

  function step(now) {
    const t = Math.min((now - startTime) / duration, 1); // progreso [0,1]
    const ease = t * (2 - t); // ease-out

    const x = start.x + (end.x - start.x) * ease;
    const y = start.y + (end.y - start.y) * ease;

    svg.setAttribute("viewBox", `${x} ${y} ${start.w} ${start.h}`);

    if (t < 1) requestAnimationFrame(step);
  }

  requestAnimationFrame(step);
}


//   function animate() {
//     for (const moon of moons) {
//   moon.angle += moon.speed;
//   const x = moon.planet.x + moon.radius * Math.cos(moon.angle);
//   const y = moon.planet.y + moon.radius * Math.sin(moon.angle);
//   moon.element.setAttribute("cx", x);
//   moon.element.setAttribute("cy", y);
// }
// if (!launched && currentPlanet) {
//   angle += 0.06;
//   position.x = currentPlanet.x + orbitRadius * Math.cos(angle);
//   position.y = currentPlanet.y + orbitRadius * Math.sin(angle);
//     } else {
//       position.x += velocity.x;
//       position.y += velocity.y;
//       createEngineParticle(svg, position.x, position.y, angle);
//       checkCollision();
//       // if (checkCollision()) return;
//       if (checkMoonCollision()) return;
//     }
// 
//     // ship.setAttribute("cx", position.x);
//     // ship.setAttribute("cy", position.y);
//     const angleInDegrees = angle * (180 / Math.PI);
//     // ship.setAttribute("transform", `translate(${position.x}, ${position.y}) rotate(${angleInDegrees})`);
//     ship.setAttribute("transform", `translate(${position.x - shipWidth / 2}, ${position.y - shipHeight / 2}) rotate(${angleInDegrees}, ${shipWidth / 2}, ${shipHeight / 2})`);
//     requestAnimationFrame(animate);
//   }

  document.addEventListener("click", () => {
    if (!launched) {
      launched = true;
      const speed = 5;
      velocity.x = Math.cos(angle) * speed;
      velocity.y = Math.sin(angle) * speed;
      angle = Math.atan2(velocity.y, velocity.x) + Math.PI / 2;
      // zoomOut(svg, 2.5, 1200); // Zoom out cinematográfico
    }
  });

  animate();
</script>

