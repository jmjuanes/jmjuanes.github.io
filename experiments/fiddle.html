---
{
    "title": "Fiddle",
    "description": "Minimal HTML, CSS, and JavaScript playground.",
    "layout": "empty",
    "permalink": "/lab/fiddle.html"
}
---
{{>>layout.html}}
<div id="root"></div>
<script type="text/babel">
    import React from "react";
    import ReactDOM from "react-dom/client";
    import classNames from "classnames";
    import * as codeCake from "codecake";
    import {renderIcon} from "@josemi-icons/react";

    export const LANGUAGES = {
        HTML: "html",
        CSS: "css",
        JS: "javascript"
    };

    export const LANGUAGES_DISPLAY_NAME = {
        [LANGUAGES.HTML]: "HTML",
        [LANGUAGES.CSS]: "CSS",
        [LANGUAGES.JS]: "JavaScript"
    };

    // list of default sanbox attributes
    export const SANDBOX_ATTRIBUTES = [
        "allow-downloads",
        "allow-forms",
        "allow-modals",
        "allow-pointer-lock",
        "allow-popups",
        "allow-presentation",
        "allow-same-origin",
        "allow-scripts",
    ];

    // @description create a new element with the given tag name and attributes
    const createElement = (tag, attributes = {}, content = "") => {
        const attributesArray = Object.keys(attributes).map(key => {
            return `${key}="${attributes[key]}"`;
        });
        return `<${tag} ${attributesArray.join(" ")}>${content}</${tag}>`;
    };

    // @description wrap javascript code
    const wrapJavaScriptCode = (code = "") => { 
        return `
            console.clear();
            const __execute = () => {
                const scriptTag = document.createElement("script");
                scriptTag.innerHTML = ${JSON.stringify(code)};
                document.body.appendChild(scriptTag);
            };
            document.addEventListener("DOMContentLoaded", __execute);
        `;
    };

    // @description run the code in the iframe
    const generateHtml = async (code = {}, options = {}) => {
        // TODO: we have apply transforms to the code before running it
        // 1. generate head tags
        const head = [
            createElement("style", {}, code.css || ""),
            createElement("script", {}, wrapJavaScriptCode(code.javascript || "")),
        ].join("");
        // 2. generate body content
        const body = code.html || "";
        // generate the html document
        return `<!doctype html><html><head>${head}</head><body>${body}</body></html>`;
    };

    // fiddle editor context
    export const FiddleContext = React.createContext({});

    // use fiddle context
    export const useFiddle = () => {
        return React.useContext(FiddleContext);
    };

    // fiddle provider
    export const FiddleProvider = ({children, ...props}) => {
        const [state, setState] = React.useState(() => {
            return {
                activeCode: "html",
                code: {
                    html: props.code?.html || "",
                    css: props.code?.css || "",
                    js: props.code?.javascript || props.code?.js || "",
                },
            };
        });
        const actions = React.useMemo(() => ({
            updateCode: (language, code) => {
                return setState(prevState => ({
                    ...prevState,
                    code: {
                        ...prevState.code,
                        [language]: code,
                    },
                }));
            },
            setActiveCode: language => {
                setState(prevState => ({...prevState, activeCode: language}));
            },
        }), [setState]);

        return (
            <FiddleContext value={{...state, ...actions}}>
                {children}
            </FiddleContext>
        );
    };

    // @description base layout component
    export const FiddleLayout = props => {
        return (
            <div className={classNames("flex-auto flex min-h-0", props.className)}>
                {props.children}
            </div>
        );
    };

    const CodeEditor = props => {
        const parentRef = React.useRef(null);
        const editorRef = React.useRef(null);
        const codePanelClass = classNames({
            "w-full h-full overflow-y-auto": true,
            // "CodeCake-dark": props.theme === "dark",
            // "CodeCake-light bg-cool-50": !props.theme || props.theme === "light",
        });

        // on mount, initialize editor
        React.useEffect(() => {
            editorRef.current = codeCake.create(parentRef.current, {
                language: props.language || "html",
                className: "codecake-dark h-full bg-cool-900",
                lineNumbers: true,
            });
            // initialize the code
            if (props.initialCode) {
                editorRef.current.setCode(props.initialCode);
            }
            // register on change method
            editorRef.current.onChange(code => {
                return props.onChange(props.language, code);
            });
        }, [props.onChange]);

        return (
            <div className={codePanelClass} ref={parentRef}></div>
        );
    };

    // export code editor component
    export const FiddleCodeEditor = () => {
        const fiddle = useFiddle();
        const availableCodeEditors = Object.values(LANGUAGES);
        const tabs = React.useMemo(() => {
            return availableCodeEditors.map(key => {
                const tabActive = key === fiddle.activeCode;
                const tabClassName = classNames({
                    "flex justify-center gap-2 cursor-pointer px-4 py-3 w-32 font-bold": true,
                    "font-bold text-white bg-cool-900 rounded-tl-lg rounded-tr-lg": tabActive,
                    "opacity-30 hover:opacity-100": !tabActive
                });
                const tabClick = () => fiddle.setActiveCode(key);
                return (
                    <div key={"tab:" + key} className={tabClassName} onClick={tabClick}>
                        <span className="text-sm">{LANGUAGES_DISPLAY_NAME[key]}</span>
                    </div>
                );
            });
        }, [fiddle.activeCode, fiddle.setActiveCode, availableCodeEditors.join(",")]);

        return (
            <div className="w-full h-full flex flex-col">
                <div className="flex gap-1 bg-cool-800 select-none">{tabs}</div>
                {availableCodeEditors.map(tab => (
                    <div key={tab} className={classNames("flex-auto", {"hidden": !(tab === fiddle.activeCode)})}>
                        <CodeEditor
                            key={"editor:" + tab}
                            language={tab}
                            initialCode={fiddle.code[tab]}
                            onChange={fiddle.updateCode}
                        />
                    </div>
                ))}
            </div>
        );
    };

    // @description output fiddle
    export const FiddleOutput = props => {
        const fiddle = useFiddle();
        const [iframeExecutionId, setIframeExecutionId] = React.useState(0);
        const currentExecutionId = React.useRef(iframeExecutionId);
        const iframeRef = React.useRef(null);

        // delay the update of the iframe
        // useDebounce(
        //     () => setIframeExecutionId(iframeExecutionId + 1),
        //     props.executionDelay || 1000,
        //     [fiddle.code?.html, fiddle.code?.css, fiddle.code?.javascript],
        // );
        React.useEffect(() => {
            const delayedFnTimer = window.setTimeout(() => {
                setIframeExecutionId(iframeExecutionId + 1);
            }, props.execitionDelay || 1000);
            return () => {
                window.clearTimeout(delayedFnTimer);
            };
        }, [fiddle?.code?.html, fiddle?.code?.css, fiddle?.code?.javascript]);

        // effect to update the iframe content
        React.useEffect(() => {
            currentExecutionId.current = iframeExecutionId; // store the current execution id
            if (iframeRef.current && fiddle.code) {
                generateHtml(fiddle.code, {}).then(html => {
                    // if the execution id has changed, do not continue
                    if (currentExecutionId.current !== iframeExecutionId) {
                        return;
                    }
                    // write the html content to the iframe
                    iframeRef.current.contentWindow.document.open();
                    iframeRef.current.contentWindow.document.write(html);
                    iframeRef.current.contentWindow.document.close();
                });
            }
        }, [iframeExecutionId]);

        return (
            <div className="w-full h-full relative">
                <iframe
                    key={iframeExecutionId}
                    ref={iframeRef}
                    className="w-full h-full border-0 bg-white"
                    scrolling="yes"
                    sandbox={SANDBOX_ATTRIBUTES.join(" ")}
                />
            </div>
        );
    };

    // @description main app component
    const App = () => {
        const initialCode = {
            html: "<div>Hello, world!</div>",
        };

        return (
            <div className="fixed top-0 left-0 bg-cool-900 text-white text-base flex flex-col flex-none w-full h-screen">
                <FiddleProvider code={initialCode}>
                    <FiddleLayout className="h-full w-full">
                        <FiddleCodeEditor />
                        <FiddleOutput />
                    </FiddleLayout>
                </FiddleProvider>
            </div>
        );
    };

    // render app
    ReactDOM.createRoot(document.getElementById("root")).render((
        <App />
    ));
</script>
{{/layout.html}}
