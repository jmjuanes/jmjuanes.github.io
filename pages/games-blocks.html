---
title: "Blocks"
description: "Blocks game"
layout: "page"
permalink: "games/blocks.html"
---
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Nunito:wght@800&display=swap">
<div class="w-full flex items-center justify-center rounded-xl bg-neutral-100 overflow-x-hidden">
    <svg width="0px" height="0px"></svg>
</div>

<script type="module">
    const COLORS = {
        WHITE: "#FFF",
        TRANSPARENT: "transparent",
        DARK_GRAY: "#8A919B",
        LIGHT_GRAY: "#D7D7D7",
        DARK_RED: "#AE1946",
        LIGHT_RED: "#E23267",
        DARK_PURPLE: "#34263B",
        LIGHT_PURPLE: "#5C4469",
    };
    const GAME_MAX_WIDTH = 600; // max width of the game
    const GAME_MAX_HEIGHT = 350; // height of the game
    const GAME_SCREENS = {
        MENU: "screen:menu",
        GAME: "screen:game",
    };
    const GAME_TEXT_FONT = "Nunito";
    const GAME_TEXT_WEIGHT = "800";
    const BLOCK_SIZE = 45; // size of the block element
    const BLOCK_GAP = 5; // gap between blocks
    const BLOCK_RADIUS = 10; // radius of the block element
    const BLOCK_COLORS = [COLORS.LIGHT_RED, COLORS.LIGHT_PURPLE];
    const BLOCK_BORDER_COLORS = [COLORS.DARK_RED, COLORS.DARK_PURPLE];
    const BLOCK_BORDER_WIDTH = 5;
    const BLOCKS_BACKGROUND = COLORS.WHITE;
    const BLOCKS_BORDER_COLOR = COLORS.LIGHT_GRAY;
    const BLOCKS_BORDER_WIDTH = 3;
    const BLOCKS_RADIUS = 15;
    const BLOCKS_OFFSET = 10; // offset of the blocks area
    const BUTTON_HEIGHT = 40; // height of the button
    const BUTTON_BORDER_WIDTH = 5; // border width of the button
    const BUTTON_BORDER_RADIUS = 10; // border radius of the button
    const BUTTON_TEXT_SIZE = "16px"; // font size of the button text

    const clone = value => {
        return JSON.parse(JSON.stringify(value));
    };

    const createSvgElement = (parent, name, attributes = {}) => {
        const element = document.createElementNS("http://www.w3.org/2000/svg", name);
        Object.keys(attributes).forEach(key => {
            element.setAttribute(key, attributes[key]);
        });
        if (parent) {
            parent.appendChild(element);
        }
        return element;
    };
   
    // game
    const $game = {
        width: 0,
        height: 0,
        canvas: document.querySelector("svg"),
        currentScreen: null,
        currentLevel: null,
        levels: [],

        // @description the provided changes to the matrix
        applyChanges: (currentMatrix, changes = []) => {
            const matrix = clone(currentMatrix);
            changes.forEach(([x, y]) => {
                [x - 1, x, x + 1].forEach(i => {
                    [y - 1, y, y + 1].forEach(j => {
                        if (matrix[i] && matrix[i][j] !== undefined) {
                            matrix[i][j] = matrix[i][j] === 0 ? 1 : 0;
                        }
                    });
                });
            });
            return matrix;
        },

        // @descript get differences between two maxixes
        getMatrixDifferences: (matrix1, matrix2) => {
            const differences = [];
            matrix1.forEach((row, i) => {
                return row.forEach((value, j) => {
                    if (matrix2[i][j] !== value) {
                        differences.push([i, j]);
                    }
                });
            });
            return differences;
        },

        // @description play the game
        play: level => {
            $game.currentLevel = level; // save reference to the current level
            const parent = createSvgElement($game.canvas, "g", {
                "data-role": "screen",
            });
            // const targetMatrix = level.target;
            level.moves = 0; // initialize number of moves
            level.changes = []; // initialize changes history
            level.matrix = $game.applyChanges(level.targetMatrix, clone(level.targetChanges).reverse());
            // render the moves counter
            const movesCounterParent = createSvgElement(parent, "g", {
                "data-resize": "true",
                "data-role": "game:moves",
                "data-width": "50",
                "data-height": "0",
                "data-x": "0.6",
                "data-y": "0",
            });
            createSvgElement(movesCounterParent, "rect", {
                "x": "0",
                "y": "-10",
                "width": "50",
                "height": "60",
                "rx": "10",
                "fill": BLOCKS_BORDER_COLOR,
            });
            createSvgElement(movesCounterParent, "rect", {
                "x": "0",
                "y": "-10",
                "width": "50",
                "height": "57",
                "rx": "10",
                "fill": "#FFF",
            });
            createSvgElement(movesCounterParent, "text", {
                "data-role": "game:moves:counter",
                "x": "25",
                "y": "20",
                "text-anchor": "middle",
                "dominant-baseline": "middle",
                "font-size": "20px",
                "fill": COLORS.DARK_GRAY,
                "font-family": GAME_TEXT_FONT,
                "font-weight": GAME_TEXT_WEIGHT,
            }).textContent = level.moves;
            createSvgElement(movesCounterParent, "text", {
                "x": "25",
                "y": "35",
                "text-anchor": "middle",
                "dominant-baseline": "middle",
                "font-size": "12px",
                "fill": COLORS.DARK_GRAY,
                "font-family": GAME_TEXT_FONT,
                "font-weight": GAME_TEXT_WEIGHT,
            }).textContent = "moves";
            // render the game
            const targetMatrixParent = createSvgElement(parent, "g", {
                "data-resize": "true",
                "data-role": "game:matrix:target",
                "data-scale": "0.5",
                "data-x": "0.2",
                "data-y": "0.4",
            });
            const currentMatrixParent = createSvgElement(parent, "g", {
                "data-resize": "true",
                "data-role": "game:matrix:current",
                "data-scale": "1",
                "data-x": "0.6",
                "data-y": "0.55",
            });
            $game.renderMatrix(targetMatrixParent, level.targetMatrix, BLOCK_COLORS);
            $game.renderMatrix(currentMatrixParent, level.matrix, BLOCK_COLORS);
            // render game buttons
            $game.renderButton(parent, "Reset level", 0.2, 0.7, 150, [COLORS.WHITE, COLORS.LIGHT_GRAY, COLORS.DARK_GRAY], () => {
                $game.play(level);
            });
            // register events listeners
            Array.from(currentMatrixParent.querySelectorAll(`[data-role="block"]`)).forEach(block => {
                block.addEventListener("click", () => {
                    const row = parseInt(block.dataset.row), col = parseInt(block.dataset.col);
                    const oldMatrix = clone(level.matrix);
                    level.changes.push([row, col]);
                    level.matrix = $game.applyChanges(level.matrix, [[row, col]]);
                    level.moves++;
                    // apply changes to the matrix
                    $game.getMatrixDifferences(oldMatrix, level.matrix).forEach(([i, j]) => {
                        const v = level.matrix[i][j];
                        currentMatrixParent.querySelector(`[data-role="block:body"][data-block="${i},${j}"]`).setAttribute("fill", BLOCK_COLORS[v]);
                        currentMatrixParent.querySelector(`[data-role="block:border"][data-block="${i},${j}"]`).setAttribute("fill", BLOCK_BORDER_COLORS[v]);
                    });
                    // update the moves counter
                    $game.canvas.querySelector(`[data-role="game:moves:counter"]`).textContent = level.moves;
                });
            });

            // resize the screen
            $game.resizeScreen();
        },

        // @description render the blocks matrix in the provided group element
        renderMatrix: (parent, matrix) => {
            const rows = matrix.length, cols = matrix[0].length;
            // 1. render the background of the blocks area
            const bgOffsets = [BLOCKS_BORDER_WIDTH, 0];
            const bgColors = [BLOCKS_BORDER_COLOR, BLOCKS_BACKGROUND];
            [0, 1].forEach(index => {
                createSvgElement(parent, "rect", {
                    "x": 0,
                    "y": bgOffsets[index],
                    "width": cols * BLOCK_SIZE + (cols - 1) * BLOCK_GAP + 2 * BLOCKS_OFFSET,
                    "height": rows * BLOCK_SIZE + (rows - 1) * BLOCK_GAP + 2 * BLOCKS_OFFSET,
                    "fill": bgColors[index],
                    "rx": BLOCKS_RADIUS,
                });
            });
            // 2. render the blocks
            matrix.forEach((row, i) => {
                return row.forEach((value, j) => {
                    createSvgElement(parent, "rect", {
                        "data-role": "block:border",
                        "data-block": `${i},${j}`,
                        "x": j * (BLOCK_SIZE + BLOCK_GAP) + BLOCKS_OFFSET,
                        "y": i * (BLOCK_SIZE + BLOCK_GAP) + BLOCKS_OFFSET,
                        "width": BLOCK_SIZE,
                        "height": BLOCK_SIZE,
                        "fill": BLOCK_BORDER_COLORS[value],
                        "rx": BLOCK_RADIUS,
                    });
                    createSvgElement(parent, "rect", {
                        "data-role": "block:body",
                        "data-block": `${i},${j}`,
                        "x": j * (BLOCK_SIZE + BLOCK_GAP) + BLOCKS_OFFSET,
                        "y": i * (BLOCK_SIZE + BLOCK_GAP) + BLOCKS_OFFSET,
                        "width": BLOCK_SIZE,
                        "height": BLOCK_SIZE - BLOCK_BORDER_WIDTH,
                        "fill": BLOCK_COLORS[value],
                        "rx": BLOCK_RADIUS,
                    });
                    createSvgElement(parent, "rect", {
                        "data-role": "block",
                        "data-row": i,
                        "data-col": j,
                        "x": j * (BLOCK_SIZE + BLOCK_GAP) + BLOCKS_OFFSET,
                        "y": i * (BLOCK_SIZE + BLOCK_GAP) + BLOCKS_OFFSET,
                        "width": BLOCK_SIZE,
                        "height": BLOCK_SIZE,
                        "fill": COLORS.TRANSPARENT,
                    });
                });
            });
            // 3. set attributes to the parent container
            parent.setAttribute("data-width", cols * BLOCK_SIZE + (cols - 1) * BLOCK_GAP + 2 * BLOCKS_OFFSET);
            parent.setAttribute("data-height", rows * BLOCK_SIZE + (rows - 1) * BLOCK_GAP + 2 * BLOCKS_OFFSET);
            return parent;
        },

        // @description render a button
        renderButton: (parent, text, x, y, width, colors, onClick) => {
            const button = createSvgElement(parent, "g", {
                "data-role": "button",
                "data-resize": "true",
                "data-x": x,
                "data-y": y,
                "data-width": width,
                "data-height": BUTTON_HEIGHT,
            });
            createSvgElement(button, "rect", {
                "data-role": "button:border",
                "x": 0,
                "y": BUTTON_BORDER_WIDTH,
                "width": width,
                "height": BUTTON_HEIGHT - BUTTON_BORDER_WIDTH,
                "fill": colors[1],
                "rx": BUTTON_BORDER_RADIUS
            });
            createSvgElement(button, "rect", {
                "data-role": "button:main",
                "x": 0,
                "y": 0,
                "width": width,
                "height": BUTTON_HEIGHT - BUTTON_BORDER_WIDTH,
                "fill": colors[0],
                "rx": BUTTON_BORDER_RADIUS
            });
            createSvgElement(button, "text", {
                "data-role": "button:text",
                "x": width / 2,
                "y": BUTTON_HEIGHT / 2,
                "text-anchor": "middle",
                "dominant-baseline": "middle",
                "font-size": BUTTON_TEXT_SIZE,
                "fill": colors[2],
                "font-family": GAME_TEXT_FONT,
                "font-weight": GAME_TEXT_WEIGHT,
            }).textContent = text;
            button.addEventListener("pointerdown", () => {
                button.querySelector(`[data-role="button:main"]`).setAttribute("fill", COLORS.TRANSPARENT);
                button.querySelector(`[data-role="button:text"]`).setAttribute("y", (BUTTON_HEIGHT / 2) + BUTTON_BORDER_WIDTH);
            });
            button.addEventListener("pointerup", () => {
                button.querySelector(`[data-role="button:main"]`).setAttribute("fill", colors[0]);
                button.querySelector(`[data-role="button:text"]`).setAttribute("y", BUTTON_HEIGHT / 2);
                // onClick();
            });
            return button;
        },

        // @description resize screen
        resizeScreen: () => {
            // 1. center the game area
            const centerX = $game.width / 2, centerY = $game.height / 2;
            Array.from($game.canvas.querySelectorAll(`g[data-resize="true"]`)).forEach(group => {
                const scale = parseFloat(group.getAttribute("data-scale") ?? 1);
                const width = parseInt(group.getAttribute("data-width") ?? 0) * scale;
                const height = parseInt(group.getAttribute("data-height") ?? 0) * scale;
                const x = parseFloat(group.getAttribute("data-x") ?? 0) * $game.width;
                const y = parseFloat(group.getAttribute("data-y") ?? 0) * $game.height;
                group.setAttribute("transform", `translate(${x - width / 2}, ${y - height / 2}) scale(${scale})`);
            });
        },

        // @description resize the game
        handleResize: () => {
            const {width, height} = $game.canvas.parentElement.getBoundingClientRect();
            $game.width = Math.min(GAME_MAX_WIDTH, width);
            $game.height = GAME_MAX_HEIGHT;
            $game.canvas.setAttribute("width", $game.width + "px");
            $game.canvas.setAttribute("height", $game.height + "px");
            // TODO: resize game elements
        },

        // @description initialize the game
        init: () => {
            // $game.canvas.parentElement.style.backgroundColor = GAME_BACKGROUND;
            $game.handleResize();
            // window.addEventListener("resize", $game.handleResize);

            $game.play({
                targetMatrix: [[0, 1, 0, 1, 0], [1, 0, 1, 0, 1], [0, 1, 0, 1, 0], [1, 0, 1, 0, 1], [0, 1, 0, 1, 0]],
                targetChanges: [[1, 1]],
                maxMoves: 1,
            });
        },
    };

    // initialize the game
    $game.init();
</script>
