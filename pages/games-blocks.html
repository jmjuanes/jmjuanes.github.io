---
title: "Blocks"
description: "Blocks game"
layout: "page"
permalink: "games/blocks.html"
---
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Nunito:wght@800&display=swap">
<div class="w-full flex items-center justify-center rounded-xl bg-neutral-100 overflow-x-hidden">
    <svg width="0px" height="0px"></svg>
</div>

<script type="module">
    const COLORS = {
        WHITE: "#FFF",
        BLACK: "#000",
        TRANSPARENT: "transparent",
        RED: ["#ED5565", "#DA4453"],
        ORANGE: ["#FC6E51", "#E9573F"],
        YELLOW: ["#FFCE54", "#F6BB42"],
        GREEN: ["#A0D468", "#8CC152"],
        AQUA: ["#4FC1E9", "#3BAFDA"],
        BLUE: ["#5D9CEC", "#4A89DC"],
        PURPLE: ["#AC92EC", "#967ADC"],
        PINK: ["#EC87C0", "#D770AD"],
        MINT: ["#48CFAD", "#37BC9B"],
        LIGHT_GRAY: ["#F5F7FA", "#E6E9ED"],
        MEDIUM_GRAY: ["#CCD1D9", "#AAB2BD"],
        DARK_GRAY: ["#656D78", "#434A54"],
    };
    const GAME_MAX_WIDTH = 600; // max width of the game
    const GAME_MAX_HEIGHT = 350; // height of the game
    const GAME_SCREENS = {
        MENU: "screen:menu",
        GAME: "screen:game",
    };
    const GAME_TEXT_FONT = "Nunito";
    const GAME_TEXT_WEIGHT = "800";
    const BLOCK_SIZE = 45; // size of the block element
    const BLOCK_GAP = 5; // gap between blocks
    const BLOCK_RADIUS = 10; // radius of the block element
    const BLOCK_COLORS = [COLORS.RED[0], COLORS.ORANGE[0]];
    const BLOCK_BORDER_COLORS = [COLORS.RED[1], COLORS.ORANGE[1]];
    const BLOCK_BORDER_WIDTH = 5;
    const BLOCKS_BACKGROUND = COLORS.WHITE;
    const BLOCKS_BORDER_COLOR = COLORS.LIGHT_GRAY[1];
    const BLOCKS_BORDER_WIDTH = 3;
    const BLOCKS_RADIUS = 15;
    const BLOCKS_OFFSET = 10; // offset of the blocks area
    const BUTTON_HEIGHT = 40; // height of the button
    const BUTTON_BORDER_WIDTH = 5; // border width of the button
    const BUTTON_BORDER_RADIUS = 10; // border radius of the button
    const BUTTON_TEXT_SIZE = "16px"; // font size of the button text
    const BASE_MATRIX = [
        [[0, 1, 0], [1, 0, 1], [0, 1, 0]],
        [[1, 0, 0, 1], [0, 1, 1, 0], [0, 1, 1, 0], [1, 0, 0, 1]],
    ];

    const clone = value => {
        return JSON.parse(JSON.stringify(value));
    };

    // generate a randon number between the provided range
    const random = (min, max) => {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    };

    const createSvgElement = (parent, name, attributes = {}) => {
        const element = document.createElementNS("http://www.w3.org/2000/svg", name);
        Object.keys(attributes).forEach(key => {
            element.setAttribute(key, attributes[key]);
        });
        if (parent) {
            parent.appendChild(element);
        }
        return element;
    };
   
    // game
    const $game = {
        width: 0,
        height: 0,
        canvas: document.querySelector("svg"),
        currentScreen: null,
        currentLevel: null,
        levels: [],

        // @description the provided changes to the matrix
        applyChanges: (currentMatrix, changes = []) => {
            const matrix = clone(currentMatrix);
            changes.forEach(([x, y]) => {
                [x - 1, x, x + 1].forEach(i => {
                    [y - 1, y, y + 1].forEach(j => {
                        if (matrix[i] && matrix[i][j] !== undefined) {
                            matrix[i][j] = matrix[i][j] === 0 ? 1 : 0;
                        }
                    });
                });
            });
            return matrix;
        },

        // @descript get differences between two maxixes
        getMatrixDifferences: (matrix1, matrix2) => {
            const differences = [];
            matrix1.forEach((row, i) => {
                return row.forEach((value, j) => {
                    if (matrix2[i][j] !== value) {
                        differences.push([i, j]);
                    }
                });
            });
            return differences;
        },

        // @description create a new level
        createLevel: () => {
            const level = {
                targetMatrix: BASE_MATRIX[random(0, BASE_MATRIX.length - 1)],
                targetChanges: [],
            };
            const maxRows = level.targetMatrix.length, maxCols = level.targetMatrix[0].length;
            const maxChanges = random(1, maxRows - 1);
            // TODO: optimize the generation of the target changes
            for (let i = 0; i < maxChanges; i++) {
                let row = random(0, maxRows - 1), col = random(0, maxCols - 1);
                level.targetChanges.push([row, col]);
            }
            return level;
        },

        // @description play the game
        play: level => {
            $game.currentLevel = level; // save reference to the current level
            $game.canvas.replaceChildren(); // clear the canvas
            const parent = createSvgElement($game.canvas, "g", {
                "data-role": "screen",
            });
            // const targetMatrix = level.target;
            level.moves = 0; // initialize number of moves
            level.changes = []; // initialize changes history
            level.matrix = $game.applyChanges(level.targetMatrix, clone(level.targetChanges).reverse());
            // render the moves counter
            const movesCounterParent = createSvgElement(parent, "g", {
                "data-resize": "true",
                "data-role": "game:moves",
                "data-width": "50",
                "data-height": "0",
                "data-x": "0.6",
                "data-y": "0",
            });
            createSvgElement(movesCounterParent, "rect", {
                "x": "0",
                "y": "-10",
                "width": "50",
                "height": "60",
                "rx": "10",
                "fill": COLORS.LIGHT_GRAY[1],
            });
            createSvgElement(movesCounterParent, "rect", {
                "x": "0",
                "y": "-10",
                "width": "50",
                "height": "57",
                "rx": "10",
                "fill": COLORS.WHITE,
            });
            createSvgElement(movesCounterParent, "text", {
                "data-role": "game:moves:counter",
                "x": "25",
                "y": "20",
                "text-anchor": "middle",
                "dominant-baseline": "middle",
                "font-size": "20px",
                "fill": COLORS.DARK_GRAY[0],
                "font-family": GAME_TEXT_FONT,
                "font-weight": GAME_TEXT_WEIGHT,
            }).textContent = `${level.moves}/${level.targetChanges.length}`;
            createSvgElement(movesCounterParent, "text", {
                "x": "25",
                "y": "35",
                "text-anchor": "middle",
                "dominant-baseline": "middle",
                "font-size": "12px",
                "fill": COLORS.MEDIUM_GRAY[1],
                "font-family": GAME_TEXT_FONT,
                "font-weight": GAME_TEXT_WEIGHT,
            }).textContent = "moves";
            // render the game
            const targetMatrixParent = createSvgElement(parent, "g", {
                "data-resize": "true",
                "data-role": "game:matrix:target",
                "data-scale": "0.5",
                "data-x": "0.2",
                "data-y": "0.4",
            });
            const currentMatrixParent = createSvgElement(parent, "g", {
                "data-resize": "true",
                "data-role": "game:matrix:current",
                "data-scale": "1",
                "data-x": "0.6",
                "data-y": "0.55",
            });
            $game.renderMatrix(targetMatrixParent, level.targetMatrix, BLOCK_COLORS);
            $game.renderMatrix(currentMatrixParent, level.matrix, BLOCK_COLORS);
            // render game buttons
            $game.renderButton(parent, 0.2, 0.7, {
                text: "Restart level",
                width: 150,
                colors: [COLORS.WHITE, COLORS.LIGHT_GRAY[1], COLORS.DARK_GRAY[0]],
                onClick: () => {
                    $game.play(level);
                },
            });
            // register events listeners
            Array.from(currentMatrixParent.querySelectorAll(`[data-role="block"]`)).forEach(block => {
                block.addEventListener("click", () => {
                    const row = parseInt(block.dataset.row), col = parseInt(block.dataset.col);
                    const oldMatrix = clone(level.matrix);
                    level.changes.push([row, col]);
                    level.matrix = $game.applyChanges(level.matrix, [[row, col]]);
                    level.moves++;
                    // apply changes to the matrix
                    $game.getMatrixDifferences(oldMatrix, level.matrix).forEach(([i, j]) => {
                        const v = level.matrix[i][j];
                        currentMatrixParent.querySelector(`[data-role="block:body"][data-block="${i},${j}"]`).setAttribute("fill", BLOCK_COLORS[v]);
                        currentMatrixParent.querySelector(`[data-role="block:border"][data-block="${i},${j}"]`).setAttribute("fill", BLOCK_BORDER_COLORS[v]);
                    });
                    // update the moves counter
                    $game.canvas.querySelector(`[data-role="game:moves:counter"]`).textContent = `${level.moves}/${level.targetChanges.length}`;
                    // check if the level is completed
                    if ($game.getMatrixDifferences(level.matrix, level.targetMatrix).length === 0) {
                        $game.renderSuccessScreen();
                    }
                    // check for game over
                    if (level.moves >= level.targetChanges.length) {
                        // $game.renderGameOverScreen();
                    }
                });
            });

            // resize the screen
            $game.renderSuccessScreen();
            $game.resizeScreen();
        },

        // @description render the blocks matrix in the provided group element
        renderMatrix: (parent, matrix) => {
            const rows = matrix.length, cols = matrix[0].length;
            // 1. render the background of the blocks area
            const bgOffsets = [BLOCKS_BORDER_WIDTH, 0];
            const bgColors = [BLOCKS_BORDER_COLOR, BLOCKS_BACKGROUND];
            [0, 1].forEach(index => {
                createSvgElement(parent, "rect", {
                    "x": 0,
                    "y": bgOffsets[index],
                    "width": cols * BLOCK_SIZE + (cols - 1) * BLOCK_GAP + 2 * BLOCKS_OFFSET,
                    "height": rows * BLOCK_SIZE + (rows - 1) * BLOCK_GAP + 2 * BLOCKS_OFFSET,
                    "fill": bgColors[index],
                    "rx": BLOCKS_RADIUS,
                });
            });
            // 2. render the blocks
            matrix.forEach((row, i) => {
                return row.forEach((value, j) => {
                    createSvgElement(parent, "rect", {
                        "data-role": "block:border",
                        "data-block": `${i},${j}`,
                        "x": j * (BLOCK_SIZE + BLOCK_GAP) + BLOCKS_OFFSET,
                        "y": i * (BLOCK_SIZE + BLOCK_GAP) + BLOCKS_OFFSET,
                        "width": BLOCK_SIZE,
                        "height": BLOCK_SIZE,
                        "fill": BLOCK_BORDER_COLORS[value],
                        "rx": BLOCK_RADIUS,
                    });
                    createSvgElement(parent, "rect", {
                        "data-role": "block:body",
                        "data-block": `${i},${j}`,
                        "x": j * (BLOCK_SIZE + BLOCK_GAP) + BLOCKS_OFFSET,
                        "y": i * (BLOCK_SIZE + BLOCK_GAP) + BLOCKS_OFFSET,
                        "width": BLOCK_SIZE,
                        "height": BLOCK_SIZE - BLOCK_BORDER_WIDTH,
                        "fill": BLOCK_COLORS[value],
                        "rx": BLOCK_RADIUS,
                    });
                    createSvgElement(parent, "rect", {
                        "data-role": "block",
                        "data-row": i,
                        "data-col": j,
                        "x": j * (BLOCK_SIZE + BLOCK_GAP) + BLOCKS_OFFSET,
                        "y": i * (BLOCK_SIZE + BLOCK_GAP) + BLOCKS_OFFSET,
                        "width": BLOCK_SIZE,
                        "height": BLOCK_SIZE,
                        "fill": COLORS.TRANSPARENT,
                    });
                });
            });
            // 3. set attributes to the parent container
            parent.setAttribute("data-width", cols * BLOCK_SIZE + (cols - 1) * BLOCK_GAP + 2 * BLOCKS_OFFSET);
            parent.setAttribute("data-height", rows * BLOCK_SIZE + (rows - 1) * BLOCK_GAP + 2 * BLOCKS_OFFSET);
            return parent;
        },

        // @description render a button
        renderButton: (parent, x = 0, y = 0, options = {}) => {
            const button = createSvgElement(parent, "g", {
                "data-role": "button",
                "data-resize": options?.resize || "true",
                "data-x": x,
                "data-y": y,
                "data-width": options.width,
                "data-height": BUTTON_HEIGHT,
            });
            createSvgElement(button, "rect", {
                "data-role": "button:border",
                "x": 0,
                "y": BUTTON_BORDER_WIDTH,
                "width": options.width,
                "height": BUTTON_HEIGHT - BUTTON_BORDER_WIDTH,
                "fill": options.colors[1],
                "rx": BUTTON_BORDER_RADIUS
            });
            createSvgElement(button, "rect", {
                "data-role": "button:main",
                "x": 0,
                "y": 0,
                "width": options.width,
                "height": BUTTON_HEIGHT - BUTTON_BORDER_WIDTH,
                "fill": options.colors[0],
                "rx": BUTTON_BORDER_RADIUS
            });
            createSvgElement(button, "text", {
                "data-role": "button:text",
                "x": options.width / 2,
                "y": BUTTON_HEIGHT / 2,
                "text-anchor": "middle",
                "dominant-baseline": "middle",
                "font-size": BUTTON_TEXT_SIZE,
                "fill": options.colors[2],
                "font-family": GAME_TEXT_FONT,
                "font-weight": GAME_TEXT_WEIGHT,
                "style": "user-select: none;",
            }).textContent = options.text;
            button.addEventListener("pointerdown", () => {
                button.querySelector(`[data-role="button:main"]`).setAttribute("fill", COLORS.TRANSPARENT);
                button.querySelector(`[data-role="button:text"]`).setAttribute("y", (BUTTON_HEIGHT / 2) + BUTTON_BORDER_WIDTH);
            });
            button.addEventListener("pointerup", () => {
                button.querySelector(`[data-role="button:main"]`).setAttribute("fill", options.colors[0]);
                button.querySelector(`[data-role="button:text"]`).setAttribute("y", BUTTON_HEIGHT / 2);
                options.onClick();
            });
            return button;
        },

        // @description render text
        renderText: (parent, x, y, options = {}) => {
            const lines = [options.text || options.lines || []].flat();
            const group = createSvgElement(parent, "g", {
                "data-resize": options.resize ?? "true",
                "data-x": x,
                "data-y": y,
                "data-width": "0",
                "data-height": (options.size ?? 16) * 1.25 * lines.length,
            });
            lines.forEach((text, index) => {
                const textElement = createSvgElement(group, "text", {
                    "x": 0,
                    "y": index * (options.size ?? 16) * 1.25,
                    "text-anchor": "middle",
                    "dominant-baseline": "middle",
                    "font-size": options.size ?? 16,
                    "fill": options.color ?? COLORS.DARK_GRAY[0],
                    "font-family": GAME_TEXT_FONT,
                    "font-weight": GAME_TEXT_WEIGHT,
                    "style": "user-select:none;",
                });
                textElement.textContent = text;
            });
            return group;
        },

        // render an overlay screen
        renderOverlay: (parentCanvas, options = {}) => {
            const OVERLAY_OPACITY = "0.75";
            const OVERLAY_COLOR = COLORS.BLACK;
            createSvgElement(parentCanvas ?? $game.canvas, "rect", {
                "x": 0,
                "y": 0,
                "width": $game.width,
                "height": $game.height,
                "fill": options.color ?? OVERLAY_COLOR,
                "opacity": options.opacity ?? OVERLAY_OPACITY,
            });
        },

        // @description render a success screen
        renderSuccessScreen: (options = {}) => {
            $game.renderMessage($game.canvas, {
                backgroundVisible: true,
                buttons: Object.values({
                    nextLevel: {
                        text: "Next level",
                        colors: [COLORS.BLUE[0], COLORS.BLUE[1], COLORS.WHITE],
                        onClick: () => {
                            $game.play($game.createLevel());
                        },
                    },
                    restartLevel: {
                        text: "Restart level",
                        colors: [COLORS.RED[0], COLORS.RED[1], COLORS.WHITE],
                        onClick: () => {
                            $game.play($game.currentLevel);
                        },
                    },
                }),
                render: group => {
                    $game.renderText(group, "0px", "0px", {
                        text: "Level completed!",
                        // color: COLORS.WHITE,
                        size: 24,
                    });
                },
            });
            // $game.renderOverlay($game.canvas);
            // $game.renderText($game.canvas, 0.5, 0.3, {
            //     text: "Congratulations!",
            //     size: 24,
            // });
            // $game.renderText($game.canvas, 0.5, 0.38, {
            //     text: "You have completed the level.",
            //     size: 16,
            // });
            // $game.renderButton($game.canvas, 0.5, 0.7, {
            //     text: "Next level",
            //     width: 150,
            //     colors: [COLORS.BLUE[0], COLORS.BLUE[1], COLORS.WHITE],
            //     onClick: () => {
            //         $game.play($game.createLevel());
            //     },
            // });
            // $game.renderButton($game.canvas, 0.5, 0.55, {
            //     text: "Restart level",
            //     width: 150,
            //     colors: [COLORS.BLUE[0], COLORS.BLUE[1], COLORS.WHITE],
            //     onClick: () => {
            //         $game.play($game.createLevel());
            //     },
            // });
        },

        // render a message screen
        renderMessage: (parentCanvas, options = {}) => {
            const MESSAGE_WIDTH = 280;
            const MESSAGE_HEIGHT = 260;
            const MESSAGE_PADDING = 20;
            const MESSAGE_BACKGROUND_COLOR = COLORS.WHITE;
            const MESSAGE_BACKGROUND_RADIUS = 20;
            // message overlay
            $game.renderOverlay(parentCanvas, {
                opacity: options?.overlayOpacity ?? "0.8",
            });
            const parent = createSvgElement(parentCanvas ?? $game.canvas, "g", {
                "data-resize": "true",
                "data-width": MESSAGE_WIDTH,
                "data-height": MESSAGE_HEIGHT,
                "data-x": "0.5",
                "data-y": "0.5",
            });
            if (options?.backgroundVisible) {
                createSvgElement(parent, "rect", {
                    "x": 0,
                    "y": 0,
                    "width": MESSAGE_WIDTH,
                    "height": MESSAGE_HEIGHT,
                    "fill": options?.backgroundColor ?? MESSAGE_BACKGROUND_COLOR,
                    "rx": options?.backgroundRadius ?? MESSAGE_BACKGROUND_RADIUS,
                });
            }
            if (typeof options.render === "function") {
                options.render(createSvgElement(parent, "g", {
                    "data-resize": "true",
                    "data-x": (MESSAGE_WIDTH / 2) + "px",
                    "data-y": ((MESSAGE_HEIGHT - MESSAGE_PADDING - BUTTON_HEIGHT) / 2) + "px",
                    "data-width": 0, // MESSAGE_WIDTH,
                    "data-height": 0, // MESSAGE_HEIGHT - MESSAGE_PADDING - BUTTON_HEIGHT,
                }));
                // options.render(parent, MESSAGE_WIDTH, MESSAGE_HEIGHT);
            }
            // if (options.title) {
            //     const textElement = createSvgElement(parent, "text", {
            //         "x": MESSAGE_WIDTH / 2,
            //         "y": 40,
            //         "text-anchor": "middle",
            //         "dominant-baseline": "middle",
            //         "font-size": MESSAGE_TITLE_SIZE,
            //         "fill": COLORS.DARK_GRAY[0],
            //         "font-family": GAME_TEXT_FONT,
            //         "font-weight": GAME_TEXT_WEIGHT,
            //         "style": "user-select:none;",
            //     });
            //     textElement.textContent = options.title;
            // }
            const gap = 10;
            (options.buttons ?? []).forEach((button, index, buttons) => {
                const buttonWidth = (MESSAGE_WIDTH - 2 * MESSAGE_PADDING - gap * (buttons.length - 1)) / buttons.length;
                const buttonX = MESSAGE_PADDING + index * (buttonWidth + gap) + (buttonWidth / 2);
                const buttonY = MESSAGE_HEIGHT - (BUTTON_HEIGHT / 2) - MESSAGE_PADDING;
                $game.renderButton(parent, buttonX + "px", buttonY + "px", {
                    text: button.text,
                    width: buttonWidth,
                    colors: button.colors, // [COLORS.WHITE, COLORS.LIGHT_GRAY[1], COLORS.DARK_GRAY[0]],
                    onClick: button.onClick,
                });
            });
            $game.resizeScreen();
        },

        // @description resize screen
        resizeScreen: () => {
            const getPosition = (value, maxValue) => {
                return value.endsWith("px") ? parseInt(value.replace("px", "")) : (parseFloat(value) * maxValue);
            };
            // 1. center the game area
            const centerX = $game.width / 2, centerY = $game.height / 2;
            Array.from($game.canvas.querySelectorAll(`[data-resize="true"]`)).forEach(group => {
                const scale = parseFloat(group.getAttribute("data-scale") ?? 1);
                const width = parseInt(group.getAttribute("data-width") ?? 0) * scale;
                const height = parseInt(group.getAttribute("data-height") ?? 0) * scale;
                const x = getPosition(group.getAttribute("data-x") ?? "0", $game.width);
                const y = getPosition(group.getAttribute("data-y") ?? "0", $game.height);
                group.setAttribute("transform", `translate(${x - width / 2}, ${y - height / 2}) scale(${scale})`);
            });
        },

        // @description resize the game
        handleResize: () => {
            const {width, height} = $game.canvas.parentElement.getBoundingClientRect();
            $game.width = Math.min(GAME_MAX_WIDTH, width);
            $game.height = GAME_MAX_HEIGHT;
            $game.canvas.setAttribute("width", $game.width + "px");
            $game.canvas.setAttribute("height", $game.height + "px");
            // TODO: resize game elements
        },

        // @description initialize the game
        init: () => {
            // $game.canvas.parentElement.style.backgroundColor = GAME_BACKGROUND;
            $game.handleResize();
            // window.addEventListener("resize", $game.handleResize);

            $game.play($game.createLevel());
        },
    };

    // initialize the game
    $game.init();
</script>
